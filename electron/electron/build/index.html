<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="shortcut icon" href="./static/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no,maximum-scale=1,user-scalable=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="./static/manifest.json"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"><title>Iron Messenger</title><link href="./static/css/main.5e4e2d7d.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><script>window.nodeRequire=require,delete window.require</script><script src="./static/vendor/libsignal/libsignal-protocol.js"></script><script>window.require=window.nodeRequire,delete window.nodeRequire</script><script src="./static/vendor/phoenix/phoenix.js"></script><script src="./static/custom/util.js"></script><script src="./config.js"></script><script>"use strict";
      let [userId, userSessionToken] = [null, null];

      let applicationState = {
        state: {connectedUsers: [], messages: []},
        insertObject: function(key, value) {
          applicationState.state[`${key}_${value.id}`] = value;
          const all = applicationState.state[`${key}`] || new Set([]);
          applicationState.state[`${key}`] = all.add(value);
        },
        connectedUser: async function(user) {
          const connections = Array.from(applicationState.state[`connections`] || new Set([]));
          if(connections.some(function(connection){return _connected(connection, user, userId)})){
            applicationState.state.connectedUsers.push(user);
          }
        }
      };

      window.applicationState = applicationState;

      function _connected(connection, user, userId){
        return (connection.relationships.users.data[0].id == userId && connection.relationships.users.data[1].id == user.id) || (connection.relationships.users.data[1].id == userId && connection.relationships.users.data[0].id == user.id)
      }

      async function _sleep(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds))
      }

      async function _sendApiPush(apiChannel, event, options) {
        let [ready, results] = [false, null];

        const response = apiChannel.push(event, options).receive("ok", pushResults => {
          results = pushResults;
          ready = true;
        });

        while(true) {
          if (ready) {
            break;
          } else {
            await _sleep(10);
          }
        }

        return results;
      }

      async function _encryptMessage(store, address, messageString) {
        // Need to save state after encoding message
        // m - message
        let object = JSON.stringify({"type": "m", "version": "1", "data": messageString});
        let messageBuffer = util.toArrayBuffer(object);

        let sessionCipher = new libsignal.SessionCipher(store, address);
        let message = await sessionCipher.encrypt(messageBuffer);
        return message;
      }

      async function _addressToSessionKey(addressString, deviceId) {
        return `session${addressString}.${deviceId}`
      }

      async function _storeHasSession(store, addressString, deviceId) {
        return (await _addressToSessionKey(addressString, deviceId) in store.store)
      }


      // Application.get_env(:iron, :javascript)[:logging]
      const logging = true
      var logger = (function() {
        return {
          info: function(value) {
            if(logging){
              console.log(value);
            }
          },
          error: function(value) {
            console.log("ERROR: " + value);
          }
        }
      })();

      async function _randomInteger(){
        return Math.floor(Math.random() * 1000000);
      }
      async function _nullOrUndefined(value){
        return value === undefined || value === null;
      }

      async function _initMessages(userId) {
        const key = `ironMessages_${userId}`;
        const messagesPayload = window.localStorage.getItem(key);
        if (await _nullOrUndefined(messagesPayload)) {
          return [];
        } else {
          return JSON.parse(messagesPayload);
        }
      }

      async function _initState(userId){
        const key = `ironDeviceInfo_${userId}`;
        const deviceInfoPayload = window.localStorage.getItem(key);
        const messages = await _initMessages(userId);

        if (await _nullOrUndefined(deviceInfoPayload)) {
          const registrationId = KeyHelper.generateRegistrationId();
          const deviceId = await _randomInteger();
          const keyId = 1; // should be random?
          const store = new SignalProtocolStore();
          await generateIdentity(store);
          const bundle = await generatePreKeyBundle(store, keyId, keyId);
          return [registrationId, deviceId, keyId, store, messages, bundle];
        } else {
          const deviceInfo = JSON.parse(deviceInfoPayload);
          switch(deviceInfo.version) {
            case 1:
              const payload = deviceInfo.payload;
              const registrationId = payload.registrationId;
              const deviceId = payload.deviceId;
              const keyId = payload.preKeyId;
              const store = new SignalProtocolStore();
              store.put("registrationId", payload.registrationId);
              store.put("identityKey", {pubKey: util.toArrayBuffer(payload.idPubKey), privKey: util.toArrayBuffer(payload.idPrivKey)});
              store.storePreKey(keyId, {pubKey: util.toArrayBuffer(payload.preKeyPub), privKey: util.toArrayBuffer(payload.preKeyPriv)});
              store.storeSignedPreKey(keyId, {pubKey: util.toArrayBuffer(payload.signedPreKeyPub), privKey: util.toArrayBuffer(payload.signedPreKeyPriv)});
              const bundle = await getPreKeyBundle(store, keyId, keyId, util.toArrayBuffer(payload.signedSignature));

              // restore the saved sessions
              for(let key of Object.keys(payload.sessions)){
                store.put(key, payload.sessions[key])
              }

              // restore the identity keys
              for(let key of Object.keys(payload.identityKeys)){
                store.put(key, payload.identityKeys[key])
              }
              return [registrationId, deviceId, keyId, store, messages, bundle];
          }
        }
      }

      async function _savePreKeyBundleToAPI(bundle, apiChannel) {
        let payload = {
          "payload" : {
            "data": {
              "type": "pre_key_bundle",
              "attributes": {
                "identity_key": util.toString(bundle.identityKey),
                "registration_id": bundle.registrationId,
                "pre_key_id": bundle.preKey.keyId,
                "pre_key_public_key": util.toString(bundle.preKey.publicKey || ""), // The public pre key gets wiped out after decoding a message, not sure why...
                "signed_pre_key_id": bundle.signedPreKey.keyId,
                "signed_pre_key_public_key": util.toString(bundle.signedPreKey.publicKey),
                "signed_pre_key_signature": util.toString(bundle.signedPreKey.signature)
              }
            }
          }
        }

        return _sendApiPush(apiChannel, "POST:pre_key_bundles", payload);
      }

      async function _createNewInvitation(apiChannel, name, email){
        let payload = {
          "payload" : {
            "data": {
              "type": "invitation",
              "attributes": {
                "name": name,
                "email": email
              }
            }
          }
        }

        return _sendApiPush(apiChannel, "POST:invitations", payload);
      }

      async function _sendMessage(message, apiChannel, preKeyBundle, devicePreKeyBundle){
        let payload = {
          "payload" : {
            "data": {
              "type": "message",
              "attributes": {
                "type": message.type,
                "body": message.body,
                "pre_key_bundle_id": preKeyBundle.id,
                "sender_pre_key_bundle_id": devicePreKeyBundle.id
              }
            }
          }
        }

        return _sendApiPush(apiChannel, "POST:messages", payload);
      }

      async function _addressString(userId, deviceId) {
        return `${userId}_${deviceId}`
      }

      async function _decryptMessage(store, deviceId, userId, payload) {
        let addressString = await _addressString(userId, deviceId);
        let address = new libsignal.SignalProtocolAddress(addressString, deviceId);
        let sessionCipher = new libsignal.SessionCipher(store, address);
        let hasSession = await _storeHasSession(store, addressString);
        let encryptedMessage = payload.data[0].attributes;

        let message = null;

        if (encryptedMessage.type == 3) {
          message = await sessionCipher.decryptPreKeyWhisperMessage(encryptedMessage.body, "binary")
        } else {
          message = await sessionCipher.decryptWhisperMessage(encryptedMessage.body, "binary")
        }

        return JSON.parse(util.toString(message));
      }

      async function _displayMessageInUI() {
        window.apiCallbacks.newMessage();
      }

      async function _saveMessagesToMemory(messages) {
        const key = `ironMessages_${userId}`;
        window.localStorage.setItem(key, JSON.stringify(messages));
      }

      async function _saveSessionToMemory(session) {
        const key = `ironUserSession`;
        window.localStorage.setItem(key, JSON.stringify(session));
      }

      async function _initUserSession() {
        const key = `ironUserSession`;
        const sessionPayload = window.localStorage.getItem(key);
        if (sessionPayload) {
          let session = JSON.parse(sessionPayload);
          console.log(session);
          return [session.relationships.user.data.id, session.attributes.token];
        } else {
          return [null, null];
        }
      }

      async function _saveStateToMemory(store, bundle, keyId, deviceId, userId) {
        const registrationId = await store.getLocalRegistrationId();
        const idKeyPair = await store.getIdentityKeyPair();
        const preKeyPair = await store.loadPreKey(keyId);
        const signedPreKeyPair = await store.loadSignedPreKey(keyId);
        const sig = await bundle.signedPreKey.signature;
        const sessions = {};
        const identityKeys = {};

        for (let key of Object.keys(store.store)) {
          // save the current sessions
          if (key.startsWith("session")){
            sessions[key] = store.store[key];
          }
          // save the current identity keys
          if (key.startsWith("identityKey") && key != "identityKey"){
            identityKeys[key] = store.store[key];
          }
        }

        let storagePayload = {
            registrationId: registrationId,
            idPubKey: util.toString(idKeyPair.pubKey),
            idPrivKey: util.toString(idKeyPair.privKey),
            preKeyId: keyId,
            signedKeyId: keyId,
            deviceId: deviceId,
            addressString: await _addressString(userId, deviceId),
            signedPreKeyPub: util.toString(signedPreKeyPair.pubKey),
            signedPreKeyPriv: util.toString(signedPreKeyPair.privKey),
            signedSignature: util.toString(sig),
            sessions: sessions,
            identityKeys: identityKeys
          };

        if (preKeyPair && preKeyPair.pubKey) {
          storagePayload.preKeyPub = util.toString(preKeyPair.pubKey)
          storagePayload.preKeyPriv = util.toString(preKeyPair.privKey)
        }

        const ironStorage = {
          version: 1,
          payload: storagePayload
        }
        const key = `ironDeviceInfo_${userId}`;
        window.localStorage.setItem(key, JSON.stringify(ironStorage));
      }

      var controller = (function() {
        const clientVersion = "0.0.1"

        let [registrationId, deviceId, keyId, bundle, devicePreKeyBundle] = [null, null, null, null, null, null];
        let [socket, apiChannel, userDeviceChannel, loginChannel] = [null, null, null, null];
        // Need to store on disk or something
        let [store, messages] = [null, null];

        let [apiChannelReady, userDeviceChannelReady, loginChannelReady] = [false, false, false];
        let [failedToJoin] = [false];

        async function _waitForApiChannel() {
          while(true) {
            if (apiChannelReady || failedToJoin) {
              break;
            } else {
              await _sleep(10);
            }
          }
        }

        async function _waitForLoginChannel() {
          while(true) {
            if (loginChannelReady || failedToJoin) {
              break;
            } else {
              await _sleep(10);
            }
          }
        }

        return {
          asyncCall: async function() {
            logger.info("Init");

            [userId, userSessionToken] = await _initUserSession();

            await this.connectToServer();
          },
          inspectStore: async function() {
            return store;
          },
          connectToAnonymous: async function() {
          },
          connectToServer: async function() {
            logger.info("Connecting to server");
            [registrationId, deviceId, keyId, store, messages, bundle] = await _initState(userId);
            logger.info(`Device id ${deviceId}`);
            let url = `${wsProtocol}://${wsUrl}`;
            console.log(wsPort);
            console.log(Number.isInteger(wsPort));

            if (Number.isInteger(wsPort)) {
              url = url + `:${wsPort}`;
            }

            url = url + `/socket`;
            socket = new Phoenix.Socket(url,
              {
                params: {
                  userId: userId,
                  sessionToken: userSessionToken,
                  clientVersion: clientVersion,
                  deviceId: deviceId
                }
              }
            );
            userDeviceChannel = socket.channel(`user:device:connect:${userId}:${deviceId}`, {})
            apiChannel = socket.channel("api:connect", {})
            socket.connect();

            apiChannel.join()
              .receive("ok", async resp => {
                logger.info("Joined successfully", resp);
                logger.info("GET:pre_key_bundles");
                await _saveStateToMemory(store, bundle, keyId, deviceId, userId);
                let response = await _savePreKeyBundleToAPI(bundle, apiChannel);
                devicePreKeyBundle = response.payload.data[0];
                apiChannelReady = true;

                userDeviceChannel.join()
                  .receive("ok", async resp => {
                    logger.info("Joined successfully", resp);
                    userDeviceChannelReady = true;
                  })
                .receive("error", async resp => {
                  logger.info("Unable to join user", resp)
                  failedToJoin = true;
                })

              })
            .receive("error", async resp => {
              logger.info("Unable to join api", resp)
              failedToJoin = true;
            })


            loginChannel = socket.channel("login:connect", {})

            loginChannel.join()
              .receive("ok", async resp => {
                logger.info("Login joined successfully", resp);
                loginChannelReady = true;
              })
            .receive("error", async resp => { logger.info("Unable to join", resp) })

            userDeviceChannel.on("POST:messages", async (response) => {
              let encryptedMessage = response.payload.data[0]
              let preKeyBundleId = encryptedMessage.relationships.sender_pre_key_bundle.data.id;
              let senderPreKeyBundle = await this.getPreKeyBundlesById(preKeyBundleId);
              let senderDeviceId = senderPreKeyBundle.attributes.device_id;
              let senderUserId = senderPreKeyBundle.relationships.user.data.id;
              let message = await _decryptMessage(store, senderDeviceId, senderUserId, response.payload);

              delete encryptedMessage.attributes.body
              encryptedMessage.attributes.decryptedBody = message;

              await _saveStateToMemory(store, bundle, keyId, deviceId, userId);
              messages.push(encryptedMessage);
              await _saveMessagesToMemory(messages);
              await _displayMessageInUI();
            });
          },
          getMessages: async function(connectedUserId) {
            let connectedMessages = [];
            for (let i = 0; i < messages.length; i++) {
              if (messages[i].relationships.sender.data.id === connectedUserId.toString()) {
                connectedMessages.push(messages[i]);
              }
            }
            return connectedMessages;
          },
          notLoggedIn: async function () {
            await _waitForApiChannel();
            console.log(!!socket)
            console.log(failedToJoin);
            return !!(socket) && failedToJoin
          },
          getUserById: async function(userId) {
            await _waitForApiChannel();

            const usersResp = await _sendApiPush(apiChannel, "GET:users", {"id": userId});
            let user = usersResp.payload.data[0];
            applicationState.insertObject("users", user)
            applicationState.connectedUser(user);

            return user;
          },
          getPreKeyBundlesByUserId: async function(userId) {
            await _waitForApiChannel();
            const preKeyBundlesResp = await _sendApiPush(apiChannel, "GET:pre_key_bundles", {"user_id": userId});
            return preKeyBundlesResp.payload.data
          },
          getPreKeyBundlesById: async function(id) {
            await _waitForApiChannel();
            const preKeyBundlesResp = await _sendApiPush(apiChannel, "GET:pre_key_bundles", {"id": id});
            return preKeyBundlesResp.payload.data[0]
          },
          sendVerificationCode: async function(email) {
            await _waitForLoginChannel();
            const verificationResp = await _sendApiPush(loginChannel, "POST:email_verifications", {email: email});
            return verificationResp;
          },
          login: async function(email, code) {
            await _waitForLoginChannel();
            const loginResp = await _sendApiPush(loginChannel, "POST:sessions", {email: email, code: code});
            console.log(loginResp);
            if (loginResp.payload) {
              _saveSessionToMemory(loginResp.payload.data.sessions[0]);
            }

            return loginResp;
          },
          getConnectedUsers: async function() {
            await _waitForApiChannel();

            const connectionsResp = await _sendApiPush(apiChannel, "GET:connections", {});

            const connectedUsers = await Promise.all(connectionsResp.payload.data.map(async (connection) => {
              applicationState.insertObject("connections", connection)

              let connectedUserId = connection.relationships.users.data[0].id == userId ? connection.relationships.users.data[1].id : connection.relationships.users.data[0].id;
              const usersResp = await _sendApiPush(apiChannel, "GET:users", {"id": connectedUserId});
              let usersById = await Promise.all(usersResp.payload.data.map((user) => {
                applicationState.insertObject("users", user)
                applicationState.connectedUser(user);

                return user;
              }));
              return usersById[0];
            }));

            return connectedUsers;
          },
          connectedUsersSearch: async function(searchString) {
            let connectedUsers = await this.getConnectedUsers();
            searchString = searchString.toLowerCase();
            searchString = searchString.replace(/\s+/g, "");

            let searchResults = [];

            for(let i = 0; i < connectedUsers.length; i++) {
              let user = connectedUsers[i];
              let userName = user.attributes.name.toLowerCase();
              userName = userName.replace(/\s+/g, "");

              if (userName.includes(searchString)) {
                searchResults.push(user);
              }
            }

            return searchResults;
          },
          createNewInvitation: async function(name, email) {
            return _createNewInvitation(apiChannel, name, email);
          },
          sendMessage: async function(messageString, recipientUserId){
            logger.info(`Sending message ${messageString} to ${recipientUserId}`);
            const object = JSON.stringify({"type": "message", "version": "1", "data": messageString});
            const messageBuffer = util.toArrayBuffer(object);
            const preKeyBundles = await this.getPreKeyBundlesByUserId(recipientUserId);

            for (let preKeyBundle of preKeyBundles) {
              const bundleDeviceId = preKeyBundle.attributes.device_id
              const addressString = await _addressString(recipientUserId, bundleDeviceId)
              const address = new libsignal.SignalProtocolAddress(addressString, bundleDeviceId);
              if (!await _storeHasSession(store, addressString, bundleDeviceId)) {
                let sessionBuilder = new libsignal.SessionBuilder(store, address);
                let result = await sessionBuilder.processPreKey({
                  registrationId: preKeyBundle.attributes.registration_id,
                  identityKey: util.toArrayBuffer(preKeyBundle.attributes.identity_key),
                  signedPreKey: {
                      keyId     : preKeyBundle.attributes.signed_pre_key_id,
                      publicKey : util.toArrayBuffer(preKeyBundle.attributes.signed_pre_key_public_key),
                      signature : util.toArrayBuffer(preKeyBundle.attributes.signed_pre_key_signature)
                  },
                  preKey: {
                      keyId     : preKeyBundle.attributes.pre_key_id,
                      publicKey : util.toArrayBuffer(preKeyBundle.attributes.pre_key_public_key)
                  }
                });

                await _saveStateToMemory(store, bundle, keyId, deviceId, userId);
              }

              let message = await _encryptMessage(store, address, messageString)
              await _saveStateToMemory(store, bundle, keyId, deviceId, userId);
              await _sendMessage(message, apiChannel, preKeyBundle, devicePreKeyBundle)
            }
          }
        }
      })();
      window.apiCallbacks = {};
      window.controller = controller;
      controller.asyncCall();</script><div id="root"></div><script>!function(l){function e(e){for(var r,t,n=e[0],o=e[1],u=e[2],f=0,i=[];f<n.length;f++)t=n[f],p[t]&&i.push(p[t][0]),p[t]=0;for(r in o)Object.prototype.hasOwnProperty.call(o,r)&&(l[r]=o[r]);for(s&&s(e);i.length;)i.shift()();return c.push.apply(c,u||[]),a()}function a(){for(var e,r=0;r<c.length;r++){for(var t=c[r],n=!0,o=1;o<t.length;o++){var u=t[o];0!==p[u]&&(n=!1)}n&&(c.splice(r--,1),e=f(f.s=t[0]))}return e}var t={},p={2:0},c=[];function f(e){if(t[e])return t[e].exports;var r=t[e]={i:e,l:!1,exports:{}};return l[e].call(r.exports,r,r.exports,f),r.l=!0,r.exports}f.m=l,f.c=t,f.d=function(e,r,t){f.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},f.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},f.t=function(r,e){if(1&e&&(r=f(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(f.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var n in r)f.d(t,n,function(e){return r[e]}.bind(null,n));return t},f.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return f.d(r,"a",r),r},f.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},f.p="./";var r=window.webpackJsonp=window.webpackJsonp||[],n=r.push.bind(r);r.push=e,r=r.slice();for(var o=0;o<r.length;o++)e(r[o]);var s=n;a()}([])</script><script src="./static/js/1.b5fbe6b1.chunk.js"></script><script src="./static/js/main.2897abdc.chunk.js"></script></body></html>