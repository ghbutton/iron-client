{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BaseKeyType = require('./base_key_type');\n\nvar ChainType = require('./chain_type');\n\nvar SessionRecord = require('./session_record');\n\nvar crypto = require('./crypto');\n\nvar curve = require('./curve');\n\nvar errors = require('./errors');\n\nvar queueJob = require('./queue_job');\n\nvar SessionBuilder =\n/*#__PURE__*/\nfunction () {\n  function SessionBuilder(storage, protocolAddress) {\n    _classCallCheck(this, SessionBuilder);\n\n    this.addr = protocolAddress;\n    this.storage = storage;\n  }\n\n  _createClass(SessionBuilder, [{\n    key: \"initOutgoing\",\n    value: function () {\n      var _initOutgoing = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(device) {\n        var _this = this;\n\n        var fqAddr;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                fqAddr = this.addr.toString();\n                _context2.next = 3;\n                return queueJob(fqAddr,\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee() {\n                  var baseKey, devicePreKey, session, record, openSession;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return _this.storage.isTrustedIdentity(_this.addr.id, device.identityKey);\n\n                        case 2:\n                          if (_context.sent) {\n                            _context.next = 4;\n                            break;\n                          }\n\n                          throw new errors.UntrustedIdentityKeyError(_this.addr.id, device.identityKey);\n\n                        case 4:\n                          curve.verifySignature(device.identityKey, device.signedPreKey.publicKey, device.signedPreKey.signature);\n                          baseKey = curve.generateKeyPair();\n                          devicePreKey = device.preKey && device.preKey.publicKey;\n                          _context.next = 9;\n                          return _this.initSession(true, baseKey, undefined, device.identityKey, devicePreKey, device.signedPreKey.publicKey, device.registrationId);\n\n                        case 9:\n                          session = _context.sent;\n                          session.pendingPreKey = {\n                            signedKeyId: device.signedPreKey.keyId,\n                            baseKey: baseKey.pubKey\n                          };\n\n                          if (device.preKey) {\n                            session.pendingPreKey.preKeyId = device.preKey.keyId;\n                          }\n\n                          _context.next = 14;\n                          return _this.storage.loadSession(fqAddr);\n\n                        case 14:\n                          record = _context.sent;\n\n                          if (!record) {\n                            record = new SessionRecord();\n                          } else {\n                            openSession = record.getOpenSession();\n\n                            if (openSession) {\n                              console.warn(\"Closing stale open session for new outgoing prekey bundle\");\n                              record.closeSession(openSession);\n                            }\n                          }\n\n                          record.setSession(session);\n                          _context.next = 19;\n                          return _this.storage.storeSession(fqAddr, record);\n\n                        case 19:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, this);\n                })));\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function initOutgoing(_x) {\n        return _initOutgoing.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"initIncoming\",\n    value: function () {\n      var _initIncoming = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(record, message) {\n        var fqAddr, preKeyPair, signedPreKeyPair, existingOpenSession;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                fqAddr = this.addr.toString();\n                _context3.next = 3;\n                return this.storage.isTrustedIdentity(fqAddr, message.identityKey);\n\n              case 3:\n                if (_context3.sent) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, message.identityKey);\n\n              case 5:\n                if (!record.getSession(message.baseKey)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 7:\n                _context3.next = 9;\n                return this.storage.loadPreKey(message.preKeyId);\n\n              case 9:\n                preKeyPair = _context3.sent;\n\n                if (!(message.preKeyId && !preKeyPair)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                throw new errors.PreKeyError('Invalid PreKey ID');\n\n              case 12:\n                _context3.next = 14;\n                return this.storage.loadSignedPreKey(message.signedPreKeyId);\n\n              case 14:\n                signedPreKeyPair = _context3.sent;\n\n                if (signedPreKeyPair) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new errors.PreKeyError(\"Missing SignedPreKey\");\n\n              case 17:\n                existingOpenSession = record.getOpenSession();\n\n                if (existingOpenSession) {\n                  console.warn(\"Closing open session in favor of incoming prekey bundle\");\n                  record.closeSession(existingOpenSession);\n                }\n\n                _context3.t0 = record;\n                _context3.next = 22;\n                return this.initSession(false, preKeyPair, signedPreKeyPair, message.identityKey, message.baseKey, undefined, message.registrationId);\n\n              case 22:\n                _context3.t1 = _context3.sent;\n\n                _context3.t0.setSession.call(_context3.t0, _context3.t1);\n\n                return _context3.abrupt(\"return\", message.preKeyId);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function initIncoming(_x2, _x3) {\n        return _initIncoming.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"initSession\",\n    value: function () {\n      var _initSession = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(isInitiator, ourEphemeralKey, ourSignedKey, theirIdentityPubKey, theirEphemeralPubKey, theirSignedPubKey, registrationId) {\n        var sharedSecret, i, ourIdentityKey, a1, a2, a3, a4, masterKey, session;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!isInitiator) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                if (!ourSignedKey) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid call to initSession\");\n\n              case 3:\n                ourSignedKey = ourEphemeralKey;\n                _context4.next = 9;\n                break;\n\n              case 6:\n                if (!theirSignedPubKey) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                throw new Error(\"Invalid call to initSession\");\n\n              case 8:\n                theirSignedPubKey = theirEphemeralPubKey;\n\n              case 9:\n                if (!ourEphemeralKey || !theirEphemeralPubKey) {\n                  sharedSecret = new Uint8Array(32 * 4);\n                } else {\n                  sharedSecret = new Uint8Array(32 * 5);\n                }\n\n                for (i = 0; i < 32; i++) {\n                  sharedSecret[i] = 0xff;\n                }\n\n                _context4.next = 13;\n                return this.storage.getOurIdentity();\n\n              case 13:\n                ourIdentityKey = _context4.sent;\n                a1 = curve.calculateAgreement(theirSignedPubKey, ourIdentityKey.privKey);\n                a2 = curve.calculateAgreement(theirIdentityPubKey, ourSignedKey.privKey);\n                a3 = curve.calculateAgreement(theirSignedPubKey, ourSignedKey.privKey);\n\n                if (isInitiator) {\n                  sharedSecret.set(new Uint8Array(a1), 32);\n                  sharedSecret.set(new Uint8Array(a2), 32 * 2);\n                } else {\n                  sharedSecret.set(new Uint8Array(a1), 32 * 2);\n                  sharedSecret.set(new Uint8Array(a2), 32);\n                }\n\n                sharedSecret.set(new Uint8Array(a3), 32 * 3);\n\n                if (ourEphemeralKey && theirEphemeralPubKey) {\n                  a4 = curve.calculateAgreement(theirEphemeralPubKey, ourEphemeralKey.privKey);\n                  sharedSecret.set(new Uint8Array(a4), 32 * 4);\n                }\n\n                masterKey = crypto.deriveSecrets(Buffer.from(sharedSecret), Buffer.alloc(32), Buffer.from(\"WhisperText\"));\n                session = SessionRecord.createEntry();\n                session.registrationId = registrationId;\n                session.currentRatchet = {\n                  rootKey: masterKey[0],\n                  ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,\n                  lastRemoteEphemeralKey: theirSignedPubKey,\n                  previousCounter: 0\n                };\n                session.indexInfo = {\n                  created: Date.now(),\n                  used: Date.now(),\n                  remoteIdentityKey: theirIdentityPubKey,\n                  baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,\n                  baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,\n                  closed: -1\n                };\n\n                if (isInitiator) {\n                  // If we're initiating we go ahead and set our first sending ephemeral key now,\n                  // otherwise we figure it out when we first maybeStepRatchet with the remote's\n                  // ephemeral key\n                  this.calculateSendingRatchet(session, theirSignedPubKey);\n                }\n\n                return _context4.abrupt(\"return\", session);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function initSession(_x4, _x5, _x6, _x7, _x8, _x9, _x10) {\n        return _initSession.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"calculateSendingRatchet\",\n    value: function calculateSendingRatchet(session, remoteKey) {\n      var ratchet = session.currentRatchet;\n      var sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n      var masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"));\n      session.addChain(ratchet.ephemeralKeyPair.pubKey, {\n        messageKeys: {},\n        chainKey: {\n          counter: -1,\n          key: masterKey[1]\n        },\n        chainType: ChainType.SENDING\n      });\n      ratchet.rootKey = masterKey[0];\n    }\n  }]);\n\n  return SessionBuilder;\n}();\n\nmodule.exports = SessionBuilder;","map":null,"metadata":{},"sourceType":"script"}