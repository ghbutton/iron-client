{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n// vim: ts=4:sw=4\nvar BaseKeyType = require('./base_key_type');\n\nvar CLOSED_SESSIONS_MAX = 40;\nvar SESSION_RECORD_VERSION = 'v1';\n\nfunction assertBuffer(value) {\n  if (!Buffer.isBuffer(value)) {\n    throw new TypeError(\"Buffer required\");\n  }\n}\n\nvar SessionEntry =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SessionEntry() {\n    _classCallCheck(this, SessionEntry);\n\n    this._chains = {};\n  }\n\n  _createClass(SessionEntry, [{\n    key: \"toString\",\n    value: function toString() {\n      var baseKey = this.indexInfo && this.indexInfo.baseKey && this.indexInfo.baseKey.toString('base64');\n      return \"<SessionEntry [baseKey=\".concat(baseKey, \"]>\");\n    }\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return this.toString();\n    }\n  }, {\n    key: \"addChain\",\n    value: function addChain(key, value) {\n      assertBuffer(key);\n      var id = key.toString('base64');\n\n      if (this._chains.hasOwnProperty(id)) {\n        throw new Error(\"Overwrite attempt\");\n      }\n\n      this._chains[id] = value;\n    }\n  }, {\n    key: \"getChain\",\n    value: function getChain(key) {\n      assertBuffer(key);\n      return this._chains[key.toString('base64')];\n    }\n  }, {\n    key: \"deleteChain\",\n    value: function deleteChain(key) {\n      assertBuffer(key);\n      var id = key.toString('base64');\n\n      if (!this._chains.hasOwnProperty(id)) {\n        throw new ReferenceError(\"Not Found\");\n      }\n\n      delete this._chains[id];\n    }\n  }, {\n    key: \"chains\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function chains() {\n      var _arr, _i, _arr$_i, k, v;\n\n      return _regeneratorRuntime.wrap(function chains$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _arr = Object.entries(this._chains);\n              _i = 0;\n\n            case 2:\n              if (!(_i < _arr.length)) {\n                _context.next = 9;\n                break;\n              }\n\n              _arr$_i = _slicedToArray(_arr[_i], 2), k = _arr$_i[0], v = _arr$_i[1];\n              _context.next = 6;\n              return [Buffer.from(k, 'base64'), v];\n\n            case 6:\n              _i++;\n              _context.next = 2;\n              break;\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, chains, this);\n    })\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var data = {\n        registrationId: this.registrationId,\n        currentRatchet: {\n          ephemeralKeyPair: {\n            pubKey: this.currentRatchet.ephemeralKeyPair.pubKey.toString('base64'),\n            privKey: this.currentRatchet.ephemeralKeyPair.privKey.toString('base64')\n          },\n          lastRemoteEphemeralKey: this.currentRatchet.lastRemoteEphemeralKey.toString('base64'),\n          previousCounter: this.currentRatchet.previousCounter,\n          rootKey: this.currentRatchet.rootKey.toString('base64')\n        },\n        indexInfo: {\n          baseKey: this.indexInfo.baseKey.toString('base64'),\n          baseKeyType: this.indexInfo.baseKeyType,\n          closed: this.indexInfo.closed,\n          used: this.indexInfo.used,\n          created: this.indexInfo.created,\n          remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString('base64')\n        },\n        _chains: this._serialize_chains(this._chains)\n      };\n\n      if (this.pendingPreKey) {\n        data.pendingPreKey = Object.assign({}, this.pendingPreKey);\n        data.pendingPreKey.baseKey = this.pendingPreKey.baseKey.toString('base64');\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_serialize_chains\",\n    value: function _serialize_chains(chains) {\n      var r = {};\n\n      var _arr2 = Object.keys(chains);\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var key = _arr2[_i2];\n        var c = chains[key];\n        var messageKeys = {};\n\n        var _arr3 = Object.entries(c.messageKeys);\n\n        for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n          var _arr3$_i = _slicedToArray(_arr3[_i3], 2),\n              idx = _arr3$_i[0],\n              _key = _arr3$_i[1];\n\n          messageKeys[idx] = _key.toString('base64');\n        }\n\n        r[key] = {\n          chainKey: {\n            counter: c.chainKey.counter,\n            key: c.chainKey.key && c.chainKey.key.toString('base64')\n          },\n          chainType: c.chainType,\n          messageKeys: messageKeys\n        };\n      }\n\n      return r;\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      var obj = new this();\n      obj.registrationId = data.registrationId;\n      obj.currentRatchet = {\n        ephemeralKeyPair: {\n          pubKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.pubKey, 'base64'),\n          privKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.privKey, 'base64')\n        },\n        lastRemoteEphemeralKey: Buffer.from(data.currentRatchet.lastRemoteEphemeralKey, 'base64'),\n        previousCounter: data.currentRatchet.previousCounter,\n        rootKey: Buffer.from(data.currentRatchet.rootKey, 'base64')\n      };\n      obj.indexInfo = {\n        baseKey: Buffer.from(data.indexInfo.baseKey, 'base64'),\n        baseKeyType: data.indexInfo.baseKeyType,\n        closed: data.indexInfo.closed,\n        used: data.indexInfo.used,\n        created: data.indexInfo.created,\n        remoteIdentityKey: Buffer.from(data.indexInfo.remoteIdentityKey, 'base64')\n      };\n      obj._chains = this._deserialize_chains(data._chains);\n\n      if (data.pendingPreKey) {\n        obj.pendingPreKey = Object.assign({}, data.pendingPreKey);\n        obj.pendingPreKey.baseKey = Buffer.from(data.pendingPreKey.baseKey, 'base64');\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"_deserialize_chains\",\n    value: function _deserialize_chains(chains_data) {\n      var r = {};\n\n      var _arr4 = Object.keys(chains_data);\n\n      for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n        var key = _arr4[_i4];\n        var c = chains_data[key];\n        var messageKeys = {};\n\n        var _arr5 = Object.entries(c.messageKeys);\n\n        for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n          var _arr5$_i = _slicedToArray(_arr5[_i5], 2),\n              idx = _arr5$_i[0],\n              _key2 = _arr5$_i[1];\n\n          messageKeys[idx] = Buffer.from(_key2, 'base64');\n        }\n\n        r[key] = {\n          chainKey: {\n            counter: c.chainKey.counter,\n            key: c.chainKey.key && Buffer.from(c.chainKey.key, 'base64')\n          },\n          chainType: c.chainType,\n          messageKeys: messageKeys\n        };\n      }\n\n      return r;\n    }\n  }]);\n\n  return SessionEntry;\n}();\n\nvar migrations = [{\n  version: 'v1',\n  migrate: function migrateV1(data) {\n    var sessions = data._sessions;\n\n    if (data.registrationId) {\n      for (var key in sessions) {\n        if (!sessions[key].registrationId) {\n          sessions[key].registrationId = data.registrationId;\n        }\n      }\n    } else {\n      for (var _key3 in sessions) {\n        if (sessions[_key3].indexInfo.closed === -1) {\n          console.error('V1 session storage migration error: registrationId', data.registrationId, 'for open session version', data.version);\n        }\n      }\n    }\n  }\n}];\n\nvar SessionRecord =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  _createClass(SessionRecord, null, [{\n    key: \"createEntry\",\n    value: function createEntry() {\n      return new SessionEntry();\n    }\n  }, {\n    key: \"migrate\",\n    value: function migrate(data) {\n      var run = data.version === undefined;\n\n      for (var i = 0; i < migrations.length; ++i) {\n        if (run) {\n          console.info(\"Migrating session to:\", migrations[i].version);\n          migrations[i].migrate(data);\n        } else if (migrations[i].version === data.version) {\n          run = true;\n        }\n      }\n\n      if (!run) {\n        throw new Error(\"Error migrating SessionRecord\");\n      }\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      if (data.version !== SESSION_RECORD_VERSION) {\n        this.migrate(data);\n      }\n\n      var obj = new this();\n\n      if (data._sessions) {\n        var _arr6 = Object.entries(data._sessions);\n\n        for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n          var _arr6$_i = _slicedToArray(_arr6[_i6], 2),\n              key = _arr6$_i[0],\n              entry = _arr6$_i[1];\n\n          obj.sessions[key] = SessionEntry.deserialize(entry);\n        }\n      }\n\n      return obj;\n    }\n  }]);\n\n  function SessionRecord() {\n    _classCallCheck(this, SessionRecord);\n\n    this.sessions = {};\n    this.version = SESSION_RECORD_VERSION;\n  }\n\n  _createClass(SessionRecord, [{\n    key: \"serialize\",\n    value: function serialize() {\n      var _sessions = {};\n\n      var _arr7 = Object.entries(this.sessions);\n\n      for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n        var _arr7$_i = _slicedToArray(_arr7[_i7], 2),\n            key = _arr7$_i[0],\n            entry = _arr7$_i[1];\n\n        _sessions[key] = entry.serialize();\n      }\n\n      return {\n        _sessions: _sessions,\n        version: this.version\n      };\n    }\n  }, {\n    key: \"haveOpenSession\",\n    value: function haveOpenSession() {\n      var openSession = this.getOpenSession();\n      return !!openSession && typeof openSession.registrationId === 'number';\n    }\n  }, {\n    key: \"getSession\",\n    value: function getSession(key) {\n      assertBuffer(key);\n      var session = this.sessions[key.toString('base64')];\n\n      if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {\n        throw new Error(\"Tried to lookup a session using our basekey\");\n      }\n\n      return session;\n    }\n  }, {\n    key: \"getOpenSession\",\n    value: function getOpenSession() {\n      var _arr8 = Object.values(this.sessions);\n\n      for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n        var session = _arr8[_i8];\n\n        if (!this.isClosed(session)) {\n          return session;\n        }\n      }\n    }\n  }, {\n    key: \"setSession\",\n    value: function setSession(session) {\n      this.sessions[session.indexInfo.baseKey.toString('base64')] = session;\n    }\n  }, {\n    key: \"getSessions\",\n    value: function getSessions() {\n      // Return sessions ordered with most recently used first.\n      return Array.from(Object.values(this.sessions)).sort(function (a, b) {\n        var aUsed = a.indexInfo.used || 0;\n        var bUsed = b.indexInfo.used || 0;\n        return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;\n      });\n    }\n  }, {\n    key: \"closeSession\",\n    value: function closeSession(session) {\n      if (this.isClosed(session)) {\n        console.warn(\"Session already closed\", session);\n        return;\n      }\n\n      console.info(\"Closing session:\", session);\n      session.indexInfo.closed = Date.now();\n    }\n  }, {\n    key: \"openSession\",\n    value: function openSession(session) {\n      if (!this.isClosed(session)) {\n        console.warn(\"Session already open\");\n      }\n\n      console.info(\"Opening session:\", session);\n      session.indexInfo.closed = -1;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(session) {\n      return session.indexInfo.closed !== -1;\n    }\n  }, {\n    key: \"removeOldSessions\",\n    value: function removeOldSessions() {\n      while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {\n        var oldestKey = void 0;\n        var oldestSession = void 0;\n\n        var _arr9 = Object.entries(this.sessions);\n\n        for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n          var _arr9$_i = _slicedToArray(_arr9[_i9], 2),\n              key = _arr9$_i[0],\n              session = _arr9$_i[1];\n\n          if (session.indexInfo.closed !== -1 && (!oldestSession || session.indexInfo.closed < oldestSession.indexInfo.closed)) {\n            oldestKey = key;\n            oldestSession = session;\n          }\n        }\n\n        if (oldestKey) {\n          console.info(\"Removing old closed session:\", oldestSession);\n          delete this.sessions[oldestKey];\n        } else {\n          throw new Error('Corrupt sessions object');\n        }\n      }\n    }\n  }, {\n    key: \"deleteAllSessions\",\n    value: function deleteAllSessions() {\n      var _arr10 = Object.keys(this.sessions);\n\n      for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n        var key = _arr10[_i10];\n        delete this.sessions[key];\n      }\n    }\n  }]);\n\n  return SessionRecord;\n}();\n\nmodule.exports = SessionRecord;","map":null,"metadata":{},"sourceType":"script"}