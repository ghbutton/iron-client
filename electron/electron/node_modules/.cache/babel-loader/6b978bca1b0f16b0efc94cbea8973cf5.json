{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n// vim: ts=4:sw=4:expandtab\nvar ChainType = require('./chain_type');\n\nvar ProtocolAddress = require('./protocol_address');\n\nvar SessionBuilder = require('./session_builder');\n\nvar SessionRecord = require('./session_record');\n\nvar crypto = require('./crypto');\n\nvar curve = require('./curve');\n\nvar errors = require('./errors');\n\nvar protobufs = require('./protobufs');\n\nvar _queueJob = require('./queue_job');\n\nvar VERSION = 3;\n\nfunction assertBuffer(value) {\n  if (!(value instanceof Buffer)) {\n    throw TypeError(\"Expected Buffer instead of: \".concat(value.constructor.name));\n  }\n\n  return value;\n}\n\nvar SessionCipher =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SessionCipher(storage, protocolAddress) {\n    _classCallCheck(this, SessionCipher);\n\n    if (!(protocolAddress instanceof ProtocolAddress)) {\n      throw new TypeError(\"protocolAddress must be a ProtocolAddress\");\n    }\n\n    this.addr = protocolAddress;\n    this.storage = storage;\n  }\n\n  _createClass(SessionCipher, [{\n    key: \"_encodeTupleByte\",\n    value: function _encodeTupleByte(number1, number2) {\n      if (number1 > 15 || number2 > 15) {\n        throw TypeError(\"Numbers must be 4 bits or less\");\n      }\n\n      return number1 << 4 | number2;\n    }\n  }, {\n    key: \"_decodeTupleByte\",\n    value: function _decodeTupleByte(byte) {\n      return [byte >> 4, byte & 0xf];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<SessionCipher(\".concat(this.addr.toString(), \")>\");\n    }\n  }, {\n    key: \"getRecord\",\n    value: function () {\n      var _getRecord = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var record;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.storage.loadSession(this.addr.toString());\n\n              case 2:\n                record = _context.sent;\n\n                if (!(record && !(record instanceof SessionRecord))) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new TypeError('SessionRecord type expected from loadSession');\n\n              case 5:\n                return _context.abrupt(\"return\", record);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function getRecord() {\n        return _getRecord.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"storeRecord\",\n    value: function () {\n      var _storeRecord = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(record) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                record.removeOldSessions();\n                _context2.next = 3;\n                return this.storage.storeSession(this.addr.toString(), record);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function storeRecord(_x) {\n        return _storeRecord.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"queueJob\",\n    value: function () {\n      var _queueJob2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(awaitable) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _queueJob(this.addr.toString(), awaitable);\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function queueJob(_x2) {\n        return _queueJob2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(data) {\n        var _this = this;\n\n        var ourIdentityKey;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                assertBuffer(data);\n                _context5.next = 3;\n                return this.storage.getOurIdentity();\n\n              case 3:\n                ourIdentityKey = _context5.sent;\n                _context5.next = 6;\n                return this.queueJob(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee4() {\n                  var record, session, remoteIdentityKey, chain, keys, msg, msgBuf, macInput, mac, result, type, body, preKeyMsg;\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return _this.getRecord();\n\n                        case 2:\n                          record = _context4.sent;\n\n                          if (record) {\n                            _context4.next = 5;\n                            break;\n                          }\n\n                          throw new errors.SessionError(\"No sessions\");\n\n                        case 5:\n                          session = record.getOpenSession();\n\n                          if (session) {\n                            _context4.next = 8;\n                            break;\n                          }\n\n                          throw new errors.SessionError(\"No open session\");\n\n                        case 8:\n                          remoteIdentityKey = session.indexInfo.remoteIdentityKey;\n                          _context4.next = 11;\n                          return _this.storage.isTrustedIdentity(_this.addr.id, remoteIdentityKey);\n\n                        case 11:\n                          if (_context4.sent) {\n                            _context4.next = 13;\n                            break;\n                          }\n\n                          throw new errors.UntrustedIdentityKeyError(_this.addr.id, remoteIdentityKey);\n\n                        case 13:\n                          chain = session.getChain(session.currentRatchet.ephemeralKeyPair.pubKey);\n\n                          if (!(chain.chainType === ChainType.RECEIVING)) {\n                            _context4.next = 16;\n                            break;\n                          }\n\n                          throw new Error(\"Tried to encrypt on a receiving chain\");\n\n                        case 16:\n                          _this.fillMessageKeys(chain, chain.chainKey.counter + 1);\n\n                          keys = crypto.deriveSecrets(chain.messageKeys[chain.chainKey.counter], Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n                          delete chain.messageKeys[chain.chainKey.counter];\n                          msg = protobufs.WhisperMessage.create();\n                          msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;\n                          msg.counter = chain.chainKey.counter;\n                          msg.previousCounter = session.currentRatchet.previousCounter;\n                          msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));\n                          msgBuf = protobufs.WhisperMessage.encode(msg).finish();\n                          macInput = new Buffer(msgBuf.byteLength + 33 * 2 + 1);\n                          macInput.set(ourIdentityKey.pubKey);\n                          macInput.set(session.indexInfo.remoteIdentityKey, 33);\n                          macInput[33 * 2] = _this._encodeTupleByte(VERSION, VERSION);\n                          macInput.set(msgBuf, 33 * 2 + 1);\n                          mac = crypto.calculateMAC(keys[1], macInput);\n                          result = new Buffer(msgBuf.byteLength + 9);\n                          result[0] = _this._encodeTupleByte(VERSION, VERSION);\n                          result.set(msgBuf, 1);\n                          result.set(mac.slice(0, 8), msgBuf.byteLength + 1);\n                          _context4.next = 37;\n                          return _this.storeRecord(record);\n\n                        case 37:\n                          if (!session.pendingPreKey) {\n                            _context4.next = 53;\n                            break;\n                          }\n\n                          type = 3; // prekey bundle\n\n                          _context4.t0 = protobufs.PreKeyWhisperMessage;\n                          _context4.t1 = ourIdentityKey.pubKey;\n                          _context4.next = 43;\n                          return _this.storage.getOurRegistrationId();\n\n                        case 43:\n                          _context4.t2 = _context4.sent;\n                          _context4.t3 = session.pendingPreKey.baseKey;\n                          _context4.t4 = session.pendingPreKey.signedKeyId;\n                          _context4.t5 = result;\n                          _context4.t6 = {\n                            identityKey: _context4.t1,\n                            registrationId: _context4.t2,\n                            baseKey: _context4.t3,\n                            signedPreKeyId: _context4.t4,\n                            message: _context4.t5\n                          };\n                          preKeyMsg = _context4.t0.create.call(_context4.t0, _context4.t6);\n\n                          if (session.pendingPreKey.preKeyId) {\n                            preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;\n                          }\n\n                          body = Buffer.concat([Buffer.from([_this._encodeTupleByte(VERSION, VERSION)]), protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish()]);\n                          _context4.next = 55;\n                          break;\n\n                        case 53:\n                          type = 1; // normal\n\n                          body = result;\n\n                        case 55:\n                          return _context4.abrupt(\"return\", {\n                            type: type,\n                            body: body,\n                            registrationId: session.registrationId\n                          });\n\n                        case 56:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4, this);\n                })));\n\n              case 6:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function encrypt(_x3) {\n        return _encrypt.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"decryptWithSessions\",\n    value: function () {\n      var _decryptWithSessions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(data, sessions) {\n        var errs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, session, plaintext, _i, e;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (sessions.length) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new errors.SessionError(\"No sessions available\");\n\n              case 2:\n                errs = [];\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context6.prev = 6;\n                _iterator = sessions[Symbol.iterator]();\n\n              case 8:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context6.next = 25;\n                  break;\n                }\n\n                session = _step.value;\n                plaintext = void 0;\n                _context6.prev = 11;\n                _context6.next = 14;\n                return this.doDecryptWhisperMessage(data, session);\n\n              case 14:\n                plaintext = _context6.sent;\n                session.indexInfo.used = Date.now();\n                return _context6.abrupt(\"return\", {\n                  session: session,\n                  plaintext: plaintext\n                });\n\n              case 19:\n                _context6.prev = 19;\n                _context6.t0 = _context6[\"catch\"](11);\n                errs.push(_context6.t0);\n\n              case 22:\n                _iteratorNormalCompletion = true;\n                _context6.next = 8;\n                break;\n\n              case 25:\n                _context6.next = 31;\n                break;\n\n              case 27:\n                _context6.prev = 27;\n                _context6.t1 = _context6[\"catch\"](6);\n                _didIteratorError = true;\n                _iteratorError = _context6.t1;\n\n              case 31:\n                _context6.prev = 31;\n                _context6.prev = 32;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 34:\n                _context6.prev = 34;\n\n                if (!_didIteratorError) {\n                  _context6.next = 37;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 37:\n                return _context6.finish(34);\n\n              case 38:\n                return _context6.finish(31);\n\n              case 39:\n                console.error(\"Failed to decrypt message with any known session...\");\n\n                for (_i = 0; _i < errs.length; _i++) {\n                  e = errs[_i];\n                  console.error(\"Session error:\" + e, e.stack);\n                }\n\n                throw new errors.SessionError(\"No matching sessions found for message\");\n\n              case 42:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[6, 27, 31, 39], [11, 19], [32,, 34, 38]]);\n      }));\n\n      return function decryptWithSessions(_x4, _x5) {\n        return _decryptWithSessions.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"decryptWhisperMessage\",\n    value: function () {\n      var _decryptWhisperMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(data) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                assertBuffer(data);\n                _context8.next = 3;\n                return this.queueJob(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee7() {\n                  var record, result, remoteIdentityKey;\n                  return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _context7.next = 2;\n                          return _this2.getRecord();\n\n                        case 2:\n                          record = _context7.sent;\n\n                          if (record) {\n                            _context7.next = 5;\n                            break;\n                          }\n\n                          throw new errors.SessionError(\"No session record\");\n\n                        case 5:\n                          _context7.next = 7;\n                          return _this2.decryptWithSessions(data, record.getSessions());\n\n                        case 7:\n                          result = _context7.sent;\n                          remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;\n                          _context7.next = 11;\n                          return _this2.storage.isTrustedIdentity(_this2.addr.id, remoteIdentityKey);\n\n                        case 11:\n                          if (_context7.sent) {\n                            _context7.next = 13;\n                            break;\n                          }\n\n                          throw new errors.UntrustedIdentityKeyError(_this2.addr.id, remoteIdentityKey);\n\n                        case 13:\n                          if (record.isClosed(result.session)) {\n                            // It's possible for this to happen when processing a backlog of messages.\n                            // The message was, hopefully, just sent back in a time when this session\n                            // was the most current.  Simply make a note of it and continue.  If our\n                            // actual open session is for reason invalid, that must be handled via\n                            // a full SessionError response.\n                            console.warn(\"Decrypted message with closed session.\");\n                          }\n\n                          _context7.next = 16;\n                          return _this2.storeRecord(record);\n\n                        case 16:\n                          return _context7.abrupt(\"return\", result.plaintext);\n\n                        case 17:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7, this);\n                })));\n\n              case 3:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function decryptWhisperMessage(_x6) {\n        return _decryptWhisperMessage.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"decryptPreKeyWhisperMessage\",\n    value: function () {\n      var _decryptPreKeyWhisperMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(data) {\n        var _this3 = this;\n\n        var versions;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                assertBuffer(data);\n                versions = this._decodeTupleByte(data[0]);\n\n                if (!(versions[1] > 3 || versions[0] < 3)) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Incompatible version number on PreKeyWhisperMessage\");\n\n              case 4:\n                _context10.next = 6;\n                return this.queueJob(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee9() {\n                  var record, preKeyProto, builder, preKeyId, session, plaintext;\n                  return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n                    while (1) {\n                      switch (_context9.prev = _context9.next) {\n                        case 0:\n                          _context9.next = 2;\n                          return _this3.getRecord();\n\n                        case 2:\n                          record = _context9.sent;\n                          preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));\n\n                          if (record) {\n                            _context9.next = 8;\n                            break;\n                          }\n\n                          if (!(preKeyProto.registrationId == null)) {\n                            _context9.next = 7;\n                            break;\n                          }\n\n                          throw new Error(\"No registrationId\");\n\n                        case 7:\n                          record = new SessionRecord();\n\n                        case 8:\n                          builder = new SessionBuilder(_this3.storage, _this3.addr);\n                          _context9.next = 11;\n                          return builder.initIncoming(record, preKeyProto);\n\n                        case 11:\n                          preKeyId = _context9.sent;\n                          session = record.getSession(preKeyProto.baseKey);\n                          _context9.next = 15;\n                          return _this3.doDecryptWhisperMessage(preKeyProto.message, session);\n\n                        case 15:\n                          plaintext = _context9.sent;\n                          _context9.next = 18;\n                          return _this3.storeRecord(record);\n\n                        case 18:\n                          if (!preKeyId) {\n                            _context9.next = 21;\n                            break;\n                          }\n\n                          _context9.next = 21;\n                          return _this3.storage.removePreKey(preKeyId);\n\n                        case 21:\n                          return _context9.abrupt(\"return\", plaintext);\n\n                        case 22:\n                        case \"end\":\n                          return _context9.stop();\n                      }\n                    }\n                  }, _callee9, this);\n                })));\n\n              case 6:\n                return _context10.abrupt(\"return\", _context10.sent);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function decryptPreKeyWhisperMessage(_x7) {\n        return _decryptPreKeyWhisperMessage.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"doDecryptWhisperMessage\",\n    value: function () {\n      var _doDecryptWhisperMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(messageBuffer, session) {\n        var versions, messageProto, message, chain, messageKey, keys, ourIdentityKey, macInput, plaintext;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                assertBuffer(messageBuffer);\n\n                if (session) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new TypeError(\"session required\");\n\n              case 3:\n                versions = this._decodeTupleByte(messageBuffer[0]);\n\n                if (!(versions[1] > 3 || versions[0] < 3)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Incompatible version number on WhisperMessage\");\n\n              case 6:\n                messageProto = messageBuffer.slice(1, -8);\n                message = protobufs.WhisperMessage.decode(messageProto);\n                this.maybeStepRatchet(session, message.ephemeralKey, message.previousCounter);\n                chain = session.getChain(message.ephemeralKey);\n\n                if (!(chain.chainType === ChainType.SENDING)) {\n                  _context11.next = 12;\n                  break;\n                }\n\n                throw new Error(\"Tried to decrypt on a sending chain\");\n\n              case 12:\n                this.fillMessageKeys(chain, message.counter);\n\n                if (chain.messageKeys.hasOwnProperty(message.counter)) {\n                  _context11.next = 15;\n                  break;\n                }\n\n                throw new errors.MessageCounterError('Key used already or never filled');\n\n              case 15:\n                messageKey = chain.messageKeys[message.counter];\n                delete chain.messageKeys[message.counter];\n                keys = crypto.deriveSecrets(messageKey, Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n                _context11.next = 20;\n                return this.storage.getOurIdentity();\n\n              case 20:\n                ourIdentityKey = _context11.sent;\n                macInput = new Buffer(messageProto.byteLength + 33 * 2 + 1);\n                macInput.set(session.indexInfo.remoteIdentityKey);\n                macInput.set(ourIdentityKey.pubKey, 33);\n                macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n                macInput.set(messageProto, 33 * 2 + 1); // This is where we most likely fail if the session is not a match.\n                // Don't misinterpret this as corruption.\n\n                crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);\n                plaintext = crypto.decrypt(keys[0], message.ciphertext, keys[2].slice(0, 16));\n                delete session.pendingPreKey;\n                return _context11.abrupt(\"return\", plaintext);\n\n              case 30:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function doDecryptWhisperMessage(_x8, _x9) {\n        return _doDecryptWhisperMessage.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"fillMessageKeys\",\n    value: function fillMessageKeys(chain, counter) {\n      if (chain.chainKey.counter >= counter) {\n        return;\n      }\n\n      if (counter - chain.chainKey.counter > 2000) {\n        throw new errors.SessionError('Over 2000 messages into the future!');\n      }\n\n      if (chain.chainKey.key === undefined) {\n        throw new errors.SessionError('Chain closed');\n      }\n\n      var key = chain.chainKey.key;\n      chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(key, Buffer.from([1]));\n      chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));\n      chain.chainKey.counter += 1;\n      return this.fillMessageKeys(chain, counter);\n    }\n  }, {\n    key: \"maybeStepRatchet\",\n    value: function maybeStepRatchet(session, remoteKey, previousCounter) {\n      if (session.getChain(remoteKey)) {\n        return;\n      }\n\n      var ratchet = session.currentRatchet;\n      var previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);\n\n      if (previousRatchet) {\n        this.fillMessageKeys(previousRatchet, previousCounter);\n        delete previousRatchet.chainKey.key; // Close\n      }\n\n      this.calculateRatchet(session, remoteKey, false); // Now swap the ephemeral key and calculate the new sending chain\n\n      var prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);\n\n      if (prevCounter) {\n        ratchet.previousCounter = prevCounter.chainKey.counter;\n        session.deleteChain(ratchet.ephemeralKeyPair.pubKey);\n      }\n\n      ratchet.ephemeralKeyPair = curve.generateKeyPair();\n      this.calculateRatchet(session, remoteKey, true);\n      ratchet.lastRemoteEphemeralKey = remoteKey;\n    }\n  }, {\n    key: \"calculateRatchet\",\n    value: function calculateRatchet(session, remoteKey, sending) {\n      var ratchet = session.currentRatchet;\n      var sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n      var masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"),\n      /*chunks*/\n      2);\n      var chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;\n      session.addChain(chainKey, {\n        messageKeys: {},\n        chainKey: {\n          counter: -1,\n          key: masterKey[1]\n        },\n        chainType: sending ? ChainType.SENDING : ChainType.RECEIVING\n      });\n      ratchet.rootKey = masterKey[0];\n    }\n  }, {\n    key: \"hasOpenSession\",\n    value: function () {\n      var _hasOpenSession = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.queueJob(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee12() {\n                  var record;\n                  return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n                    while (1) {\n                      switch (_context12.prev = _context12.next) {\n                        case 0:\n                          _context12.next = 2;\n                          return _this4.getRecord();\n\n                        case 2:\n                          record = _context12.sent;\n\n                          if (record) {\n                            _context12.next = 5;\n                            break;\n                          }\n\n                          return _context12.abrupt(\"return\", false);\n\n                        case 5:\n                          return _context12.abrupt(\"return\", record.haveOpenSession());\n\n                        case 6:\n                        case \"end\":\n                          return _context12.stop();\n                      }\n                    }\n                  }, _callee12, this);\n                })));\n\n              case 2:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function hasOpenSession() {\n        return _hasOpenSession.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"closeOpenSession\",\n    value: function () {\n      var _closeOpenSession = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15() {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.queueJob(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee14() {\n                  var record, openSession;\n                  return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n                    while (1) {\n                      switch (_context14.prev = _context14.next) {\n                        case 0:\n                          _context14.next = 2;\n                          return _this5.getRecord();\n\n                        case 2:\n                          record = _context14.sent;\n\n                          if (!record) {\n                            _context14.next = 9;\n                            break;\n                          }\n\n                          openSession = record.getOpenSession();\n\n                          if (!openSession) {\n                            _context14.next = 9;\n                            break;\n                          }\n\n                          record.closeSession(openSession);\n                          _context14.next = 9;\n                          return _this5.storeRecord(record);\n\n                        case 9:\n                        case \"end\":\n                          return _context14.stop();\n                      }\n                    }\n                  }, _callee14, this);\n                })));\n\n              case 2:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 3:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      return function closeOpenSession() {\n        return _closeOpenSession.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return SessionCipher;\n}();\n\nmodule.exports = SessionCipher;","map":null,"metadata":{},"sourceType":"script"}