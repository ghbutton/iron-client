{"ast":null,"code":"var _classCallCheck = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./constants'),\n    CHANNEL_EVENTS = _require.CHANNEL_EVENTS,\n    CHANNEL_STATES = _require.CHANNEL_STATES;\n\nvar Push = require('./push');\n\nvar Timer = require('./timer');\n\nvar Channel =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Channel(topic, params, socket) {\n    var _this = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log(\"channel\", \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n\n      _this.socket.log(\"channel\", \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n\n      _this.socket.log(\"channel\", \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({\n        event: event,\n        callback: callback\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    } // Leaves the channel\n    //\n    // Unsubscribes from server events, and\n    // instructs channel to terminate on server\n    //\n    // Triggers onClose() hooks\n    //\n    // To receive leave acknowledgements, use the a `receive`\n    // hook to bind to the server ack, ie:\n    //\n    //     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n    //\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this2 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this2.socket.log(\"channel\", \"leave \".concat(_this2.topic));\n\n        _this2.trigger(CHANNEL_EVENTS.close, \"leave\", _this2.joinRef());\n      };\n\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    } // Overridable message hook\n    //\n    // Receives all events for specialized message handling\n    // before dispatching to the channel callbacks.\n    //\n    // Must return the payload, modified or unmodified\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    } // private\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n\n      if (ref && [close, error, leave, join].indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n\n      var handledPayload = this.onMessage(event, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n      }\n\n      this.bindings.filter(function (bind) {\n        return bind.event === event;\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n\nmodule.exports = Channel;","map":null,"metadata":{},"sourceType":"script"}