{"ast":null,"code":"var _classCallCheck = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/garybutton/Personal/iron/priv/iron/electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./constants'),\n    VSN = _require.VSN,\n    CHANNEL_EVENTS = _require.CHANNEL_EVENTS,\n    TRANSPORTS = _require.TRANSPORTS,\n    SOCKET_STATES = _require.SOCKET_STATES,\n    DEFAULT_TIMEOUT = _require.DEFAULT_TIMEOUT,\n    WS_CLOSE_NORMAL = _require.WS_CLOSE_NORMAL;\n\nvar querystring = require('querystring');\n\nvar WebSocket = require('websocket').w3cwebsocket;\n\nvar Timer = require('./timer');\n\nvar Channel = require('./channel');\n\nvar Socket =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/socket\",\n  //                                               \"wss://example.com\"\n  //                                               \"/socket\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket.\n  //\n  //   encode - The function to encode outgoing messages. Defaults to JSON:\n  //\n  //     (payload, callback) => callback(JSON.stringify(payload))\n  //\n  //   decode - The function to decode incoming messages. Defaults to JSON:\n  //\n  //     (payload, callback) => callback(JSON.parse(payload))\n  //\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n  function Socket(endPoint) {\n    var _this = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || WebSocket;\n\n    this.defaultEncoder = function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n\n    this.defaultDecoder = function (payload, callback) {\n      return callback(JSON.parse(payload));\n    };\n\n    this.encode = opts.encode || this.defaultEncoder;\n    this.decode = opts.decode || this.defaultDecoder;\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n\n    this.logger = opts.logger || function () {}; // noop\n\n\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(function () {\n      _this.disconnect(function () {\n        return _this.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      return this.appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\".concat(url).concat(prefix).concat(querystring.stringify(params));\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n\n\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n\n        this.conn = null;\n      }\n\n      callback && callback();\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = function () {\n        return _this2.onConnOpen();\n      };\n\n      this.conn.onerror = function (error) {\n        return _this2.onConnError(error);\n      };\n\n      this.conn.onmessage = function (event) {\n        return _this2.onConnMessage(event);\n      };\n\n      this.conn.onclose = function (event) {\n        return _this2.onConnClose(event);\n      };\n    } // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    } // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\n    //\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      var _this3 = this;\n\n      this.log(\"transport\", \"connected to \".concat(this.endPointURL()));\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this3.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this4 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref;\n\n      var callback = function callback() {\n        _this4.encode(data, function (result) {\n          _this4.conn.send(result);\n        });\n      };\n\n      this.log(\"push\", \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    } // Return the next message ref, accounting for overflows\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        this.conn.close(WS_CLOSE_NORMAL, \"hearbeat timeout\");\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this5 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref;\n\n        if (ref && ref === _this5.pendingHeartbeatRef) {\n          _this5.pendingHeartbeatRef = null;\n        }\n\n        _this5.log(\"receive\", \"\".concat(payload.status || \"\", \" \").concat(topic, \" \").concat(event, \" \").concat(ref && \"(\" + ref + \")\" || \"\"), payload);\n\n        _this5.channels.filter(function (channel) {\n          return channel.isMember(topic);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref);\n        });\n\n        _this5.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nmodule.exports = Socket;","map":null,"metadata":{},"sourceType":"script"}