{"ast":null,"code":"// vim: ts=4:sw=4:expandtab\n// Remove the dubious emscripten callback that invokes process.exit(1) on any\n// unhandledRejection event.\nvar _exitCallback;\n\nvar captureExitCallback = function captureExitCallback(ev, callback) {\n  if (ev === 'unhandledRejection') {\n    _exitCallback = callback; // Must remove outside emit context.\n\n    process.removeListener(ev, callback);\n  }\n};\n\nprocess.addListener('newListener', captureExitCallback);\n\nvar curve25519 = require('../build/curve25519');\n\nprocess.removeListener('newListener', captureExitCallback);\nprocess.removeListener('unhandledRejection', _exitCallback); // Insert some bytes into the emscripten memory and return a pointer\n\nfunction _allocate(bytes) {\n  var address = curve25519._malloc(bytes.length);\n\n  curve25519.HEAPU8.set(bytes, address);\n  return address;\n}\n\nfunction _readBytes(address, length, array) {\n  array.set(curve25519.HEAPU8.subarray(address, address + length));\n}\n\nvar basepoint = new Uint8Array(32);\nbasepoint[0] = 9;\n\nexports.keyPair = function (privKey) {\n  var priv = new Uint8Array(privKey);\n  priv[0] &= 248;\n  priv[31] &= 127;\n  priv[31] |= 64; // Where to store the result\n\n  var publicKey_ptr = curve25519._malloc(32); // Get a pointer to the private key\n\n\n  var privateKey_ptr = _allocate(priv); // The basepoint for generating public keys\n\n\n  var basepoint_ptr = _allocate(basepoint); // The return value is just 0, the operation is done in place\n\n\n  curve25519._curve25519_donna(publicKey_ptr, privateKey_ptr, basepoint_ptr);\n\n  var res = new Uint8Array(32);\n\n  _readBytes(publicKey_ptr, 32, res);\n\n  curve25519._free(publicKey_ptr);\n\n  curve25519._free(privateKey_ptr);\n\n  curve25519._free(basepoint_ptr);\n\n  return {\n    pubKey: res.buffer,\n    privKey: priv.buffer\n  };\n};\n\nexports.sharedSecret = function (pubKey, privKey) {\n  // Where to store the result\n  var sharedKey_ptr = curve25519._malloc(32); // Get a pointer to our private key\n\n\n  var privateKey_ptr = _allocate(new Uint8Array(privKey)); // Get a pointer to their public key, the basepoint when you're\n  // generating a shared secret\n\n\n  var basepoint_ptr = _allocate(new Uint8Array(pubKey)); // Return value is 0 here too of course\n\n\n  curve25519._curve25519_donna(sharedKey_ptr, privateKey_ptr, basepoint_ptr);\n\n  var res = new Uint8Array(32);\n\n  _readBytes(sharedKey_ptr, 32, res);\n\n  curve25519._free(sharedKey_ptr);\n\n  curve25519._free(privateKey_ptr);\n\n  curve25519._free(basepoint_ptr);\n\n  return res.buffer;\n};\n\nexports.sign = function (privKey, message) {\n  // Where to store the result\n  var signature_ptr = curve25519._malloc(64); // Get a pointer to our private key\n\n\n  var privateKey_ptr = _allocate(new Uint8Array(privKey)); // Get a pointer to the message\n\n\n  var message_ptr = _allocate(new Uint8Array(message));\n\n  curve25519._curve25519_sign(signature_ptr, privateKey_ptr, message_ptr, message.byteLength);\n\n  var res = new Uint8Array(64);\n\n  _readBytes(signature_ptr, 64, res);\n\n  curve25519._free(signature_ptr);\n\n  curve25519._free(privateKey_ptr);\n\n  curve25519._free(message_ptr);\n\n  return res.buffer;\n};\n\nexports.verify = function (pubKey, message, sig) {\n  // Get a pointer to their public key\n  var publicKey_ptr = _allocate(new Uint8Array(pubKey)); // Get a pointer to the signature\n\n\n  var signature_ptr = _allocate(new Uint8Array(sig)); // Get a pointer to the message\n\n\n  var message_ptr = _allocate(new Uint8Array(message));\n\n  var res = curve25519._curve25519_verify(signature_ptr, publicKey_ptr, message_ptr, message.byteLength);\n\n  curve25519._free(publicKey_ptr);\n\n  curve25519._free(signature_ptr);\n\n  curve25519._free(message_ptr);\n\n  if (res !== 0) {\n    throw new Error(\"Invalid signature\");\n  }\n};","map":null,"metadata":{},"sourceType":"script"}