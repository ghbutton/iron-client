{"ast":null,"code":"// vim: ts=4:sw=4\n'use strict';\n\nvar nodeCrypto = require('crypto');\n\nvar assert = require('assert');\n\nfunction assertBuffer(value) {\n  if (!(value instanceof Buffer)) {\n    throw TypeError(\"Expected Buffer instead of: \".concat(value.constructor.name));\n  }\n\n  return value;\n}\n\nfunction encrypt(key, data, iv) {\n  assertBuffer(key);\n  assertBuffer(data);\n  assertBuffer(iv);\n  var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(data), cipher.final()]);\n}\n\nfunction decrypt(key, data, iv) {\n  assertBuffer(key);\n  assertBuffer(data);\n  assertBuffer(iv);\n  var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([decipher.update(data), decipher.final()]);\n}\n\nfunction calculateMAC(key, data) {\n  assertBuffer(key);\n  assertBuffer(data);\n  var hmac = nodeCrypto.createHmac('sha256', key);\n  hmac.update(data);\n  return Buffer.from(hmac.digest());\n}\n\nfunction hash(data) {\n  assertBuffer(data);\n  var sha512 = nodeCrypto.createHash('sha512');\n  sha512.update(data);\n  return sha512.digest();\n} // Salts always end up being 32 bytes\n\n\nfunction deriveSecrets(input, salt, info, chunks) {\n  // Specific implementation of RFC 5869 that only returns the first 3 32-byte chunks\n  assertBuffer(input);\n  assertBuffer(salt);\n  assertBuffer(info);\n\n  if (salt.byteLength != 32) {\n    throw new Error(\"Got salt of incorrect length\");\n  }\n\n  chunks = chunks || 3;\n  assert(chunks >= 1 && chunks <= 3);\n  var PRK = calculateMAC(salt, input);\n  var infoArray = new Uint8Array(info.byteLength + 1 + 32);\n  infoArray.set(info, 32);\n  infoArray[infoArray.length - 1] = 1;\n  var signed = [calculateMAC(PRK, Buffer.from(infoArray.slice(32)))];\n\n  if (chunks > 1) {\n    infoArray.set(signed[signed.length - 1]);\n    infoArray[infoArray.length - 1] = 2;\n    signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n  }\n\n  if (chunks > 2) {\n    infoArray.set(signed[signed.length - 1]);\n    infoArray[infoArray.length - 1] = 3;\n    signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n  }\n\n  return signed;\n}\n\nfunction verifyMAC(data, key, mac, length) {\n  var calculatedMac = calculateMAC(key, data).slice(0, length);\n\n  if (mac.length !== length || calculatedMac.length !== length) {\n    throw new Error(\"Bad MAC length\");\n  }\n\n  if (!mac.equals(calculatedMac)) {\n    throw new Error(\"Bad MAC\");\n  }\n}\n\nmodule.exports = {\n  deriveSecrets: deriveSecrets,\n  decrypt: decrypt,\n  encrypt: encrypt,\n  hash: hash,\n  calculateMAC: calculateMAC,\n  verifyMAC: verifyMAC\n};","map":null,"metadata":{},"sourceType":"script"}